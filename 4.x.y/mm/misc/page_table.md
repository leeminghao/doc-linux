Linux Page Table
========================================

概述
----------------------------------------

Linux采用页表的概念来管理虚拟地址空间。MIPS与i386一样，都是二级页表结构，但有些CPU采用三级，
甚至四级结构，Linux为了兼容这些CPU，采用四级页表结构:

* PGD: Page Global Directory，页全局目录，是顶级页表。
* PUD: Page Upper Directory，页上级目录，是第二级页表
* PMD: Page Middle Derectory，页中间目录，是第三级页表。
* PTE: Page Table Entry，页面表，最后一级页表。指向物理页面。

如下所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/mm/misc/res/linux_page.JPG

图中有个cr3，它是一个寄存器，专门用于保存页全局目录的基地址，内核的主内核页全局目录的基地址保存
在swapper_pg_dir全局变量中，但需要使用主内核页表时系统会把这个变量的值放入cr3寄存器，进程们自己
的页全局目录基地址保存在自己的进程描述符的pgd中，当进程切换时，进程的页表也是需要切换的，就是
把新的进程的进程描述符的pgd存入cr3中。这些目录和页表每一个都是用一个页框进行保存，比如一个进程
有一个页全局目录，1024个页中间目录，1024个页表，那系统要为这个进程分配1个页框用于保存页全局目录，
1024个页框用于保存页中间目录，1024个页框用于保存页表。当然，进程一般情况下是不会需要这么多页
中间目录和页表的。

虚拟地址 --> 物理地址
----------------------------------------

LINUX 逻辑上把虚拟地址从高到低分成5部分，分别作为PGD、PUD、PMD、PTE的索引，以及页面内偏移。
对于CPU发出的虚拟地址，linux内存管理单元分如下五步完成从虚拟地址到物理地址的映射:

1.用虚拟地址的最高一个位段作为索引在PGD表中找到对应的表项，该表项指向一个PUD表的基地址。
2.用虚拟地址中的第二个位段作为索引在PUD表中找到对应的表项，该表项指向一个PMD表的基地址。
3.用虚拟地址中的第三个位段作为索引在PMD表中找到对应的表项，该表项指向一个PTE表的基地址。
4.用虚拟地址中的第四个位段作为索引在PTE表中找到对应的表项，该表项中存放的就是指向物理
  页面的指针（实际上是页帧号PFN和一些标志位的组合体）。
5.虚拟地址中的最后一个位段是物理页面的页内偏移，将此偏移与物理页面的起始地址相加便得到
  虚拟地址对应的物理地址。

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/mm/misc/res/virt_to_phy.jpg

ARM
----------------------------------------

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/arch/arm/mm/mmu.c/README.md
