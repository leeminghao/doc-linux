Linux进程管理
========================================

传统上，UNIX操作系统下运行的应用程序、服务器及其他程序都称为进程。每个进程都在CPU的虚拟内存中分配地址空间。
各个进程的地址空间是完全独立的，因此进程并不会意识到彼此的存在。从进程的角度来看，它会认为自己是系统中唯一
的进程。如果进程想要彼此通信（例如交换数据），那么必须使用特定的内核机制。由于Linux是多任务系统，
它支持（看上去）并发执行的若干进程。系统中同时真正在运行的进程数目最多不超过CPU数目，因此内核会按照短的时间间隔
在不同的进程之间切换（用户是注意不到的）

### 进程

Linux对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程，该进程负责进一步的系统初始化操作，
并显示登录提示符或图形登录界面（现在使用比较广泛）。因此init是进程树的根，所有进程都直接或间接起源自该进程.

UNIX操作系统中有两种创建新进程的机制，分别是fork和exec。

* fork可以创建当前进程的一个副本，父进程和子进程只有PID（进程ID）不同。在该系统调用执行之后，系统中有两个进程，
都执行同样的操作。父进程内存的内容将被复制，至少从程序的角度来看是这样。Linux使用了一种众所周知的技术来使fork
操作更高效，该技术称为写时复制（copy on write），主要的原理是将内存复制操作延迟到父进程或子进程向某内存页面写入数据之前，
在只读访问的情况下父进程和子进程可以共用同一内存页。
例如，使用fork的一种可能的情况是，用户打开另一个浏览器窗口。如果选中了对应的选项，浏览器将执行fork，复制其代码，
接下来子进程中将启动适当的操作建立新窗口。

* exec将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，其内容将替换为新的数据。然后开始执行新程序。

### 线程

进程并不是内核支持的唯一一种程序执行形式。除了重量级进程（有时也称为UNIX进程）之外，还有一种形式是线程（有时也称为轻量级进程）。
线程也已经出现相当长的一段时间，本质上一个进程可能由若干线程组成，这些线程共享同样的数据和资源，但可能执行程序中不同的代码路径。
线程概念已经完全集成到许多现代编程语言中，例如Java。简而言之，进程可以看作一个正在执行的程序，而线程则是与主程序并行运行的程序
函数或例程。该特性是有用的，例如在浏览器需要并行加载若干图像时。通常浏览器只好执行几次fork和exec调用，以此创建若干并行的进程实例。
这些进程负责加载图像，并使用某种通信机制将接收的数据提供给主程序。在使用线程时，这种情况更容易处理一些。浏览器定义了一个例程来加载图像，
可以将例程作为线程启动，使用参数不同的多个线程即可。由于线程和主程序共享同样的地址空间，主程序自动就可以访问接收到的数据。
因此除了为防止线程访问同一内存区而采取的互斥机制外，就不需要什么通信了。

Linux用clone方法创建线程。其工作方式类似于fork，但启用了精确的检查，以确认哪些资源与父进程共享、哪些资源为线程独立创建。
这种细粒度的资源分配扩展了一般的线程概念，在一定程度上允许线程与进程之间的连续转换。

### 命名空间

在内核2.6的开发期间，对命名空间的支持被集成到了许多子系统中。这使得不同的进程可以看到不同的系统视图。
传统的Linux（与一般的UNIX操作系统）使用许多全局量，例如进程ID。系统中的每个进程都有一个唯一标识符（ID），
用户（或其他进程）可使用ID来访问进程，例如向进程发一个信号。启用命名空间之后，以前的全局资源现在具有不同分组。
每个命名空间可以包含一个特定的PID集合，或可以提供文件系统的不同视图，在某个命名空间中挂载的卷不会传播到其他命名空间中。
命名空间很有用处。举例来说，该特性对虚拟主机供应商是有益的。他们不必再为每个用户准备一台物理计算机，而是通过称为
容器的命名空间来建立系统的多个视图。从容器内部看来这是一个完整的Linux系统，而且与其他容器没有交互。容器是彼此分离的。
每个容器实例看起来就像是运行Linux的一台计算机，但事实上一台物理机器可以同时运转许多这样的容器实例。这有助于更有效地使用资源。
与完全的虚拟化解决方案（如KVM）相比，计算机上只需要运行一个内核来管理所有的容器。

### 地址空间

由于内存区域是通过指针寻址，因此CPU的字长决定了所能管理的地址空间的最大长度。对32位系统（如IA-32、PPC、m68k），是2^32B=4GiB，
对更现代的64位处理器（如Alpha、Sparc64、IA-64、AMD64），可以管理2^64B。地址空间的最大长度与实际可用的物理内存数量无关，
因此被称为虚拟地址空间。使用该术语的另一个理由是，从系统中每个进程的角度来看，地址空间中只有自身一个进程，
而无法感知到其他进程的存在。应用程序无需关注其他程序的存在，好像计算机中只有一个进程一样。Linux将虚拟地址空间划分为两个部分，
分别称为内核空间和用户空间，如图所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/res/virtual_space.png

系统中每个用户进程都有自身的虚拟地址范围，从0到TASK_SIZE。用户空间之上的区域
（从TASK_SIZE到232或264）保留给内核专用，用户进程不能访问。TASK_SIZE是一个特定于
计算机体系结构的常数，把地址空间按给定比例划分为两部分。例如在IA-32系统中，
地址空间在3 GiB处划分，因此每个进程的虚拟地址空间是3 GiB。由于虚拟地址空间的总长度是4 GiB，
所以内核空间有1 GiB可用。尽管实际的数字依不同的计算机体系结构而不同，但一般概念都是相同的。
因此我在进一步讨论中将使用例子中的这些值。这种划分与可用的内存数量无关。由于地址空间虚拟化的结果，
每个用户进程都认为自身有3 GiB内存。各个系统进程的用户空间是完全彼此分离的。而虚拟地址空间顶部的
内核空间总是同样的，无论当前执行的是哪个进程。
注意，64位计算机的情况可能更复杂，因为它们在实际管理自身巨大的理论虚拟地址空间时，倾向于使用小于
64的位数。实际使用的位数一般小于64位，如42位或47位。因此，地址空间中实际可寻址的部分小于理论长度。
但无论如何，该值仍然大于计算机上实际可能的内存数量，因此是完全够用的。这种做法的一个优点是，与
寻址完整的虚拟地址空间相比，管理有效地址空间所需的位数较少，因此CPU可以节省一些工作量。这样，
虚拟地址空间会包含一些不可寻址的洞.

### 特权级别

内核把虚拟地址空间划分为两个部分，因此能够保护各个系统进程，使之彼此隔离。所有的现代CPU都提供了几种特权级别，
进程可以驻留在某一特权级别。每个特权级别都有各种限制，例如对执行某些汇编语言指令或访问虚拟地址空间某一特定部分的限制。
IA-32体系结构使用4种特权级别构成的系统，各级别可以看作是环。内环能够访问更多的功能，外环则较少，如图所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/res/virtual_space.png

尽管英特尔处理器区分4种特权级别，但Linux只使用两种不同的状态：核心态和用户状态。
两种状态的关键差别在于对高于TASK_SIZE的内存区域的访问。简而言之，在用户状态禁止访问内核空间。
用户进程不能操作或读取内核空间中的数据，也无法执行内核空间中的代码。这是内核的专用领域。
这种机制可防止进程无意间修改彼此的数据而造成相互干扰。从用户状态到核心态的切换通过系统调用
的特定转换手段完成，且系统调用的执行因具体系统而不同。如果普通进程想要执行任何影响整个系统的操作
（例如操作输入/输出装置），则只能借助于系统调用向内核发出请求。内核首先检查进程是否允许执行想要的操作，
然后代表进程执行所需的操作，接下来返回到用户状态。除了代表用户程序执行代码之外，内核还可以由异步硬件中断激活，
然后在中断上下文中运行。与在进程上下文中运行的主要区别是，在中断上下文中运行不能访问虚拟地址空间中的用户空间部分。
因为中断可能随机发生，中断发生时可能是任一用户进程处于活动状态，由于该进程基本上与中断的原因无关，
因此内核无权访问当前用户空间的内容。在中断上下文中运行时，内核必须比正常情况更加谨慎，
例如，不能进入睡眠状态。在编写中断处理程序时需要特别注意这些.

除了普通进程，系统中还有内核线程在运行。内核线程也不与任何特定的用户空间进程相关联，因此也无权处理用户空间。
不过在其他许多方面，内核线程更像是普通的用户层应用程序。与在中断上下文运转的内核相比，内核线程可以进入睡眠状态，
也可以像系统中的普通进程一样被调度器跟踪。内核线程可用于各种用途：从内存和块设备之间的数据同步，到帮助调度器在CPU上分配进程。
在多处理器系统上，许多线程启动时指定了CPU，并限制只能在某个特定的CPU上运行。从内核线程名称之后的斜线和CPU编号可以看到这一点。

进程表示
----------------------------------------

Linux内核涉及进程和程序的所有算法都围绕一个名为task_struct的数据结构建立，该结构定义如下所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/include/linux/sched_h/task_struct.md