Linux进程管理
========================================

传统上，UNIX操作系统下运行的应用程序、服务器及其他程序都称为进程。每个进程都在CPU的虚拟内存中分配
地址空间。各个进程的地址空间是完全独立的，因此进程并不会意识到彼此的存在。从进程的角度来看，它会
认为自己是系统中唯一的进程。如果进程想要彼此通信（例如交换数据），那么必须使用特定的内核机制。由于
Linux是多任务系统，它支持（看上去）并发执行的若干进程。系统中同时真正在运行的进程数目最多不超过CPU
数目，因此内核会按照短的时间间隔在不同的进程之间切换（用户是注意不到的）

常用名词
----------------------------------------

### 进程

Linux对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程，
该进程负责进一步的系统初始化操作，并显示登录提示符或图形登录界面（现在使用比较广泛）。因此
init是进程树的根，所有进程都直接或间接起源自该进程.

UNIX操作系统中有两种创建新进程的机制，分别是fork和exec。

* fork可以创建当前进程的一个副本，父进程和子进程只有PID（进程ID）不同。在该系统调用执行之后，
系统中有两个进程，都执行同样的操作。父进程内存的内容将被复制，至少从程序的角度来看是这样。Linux
使用了一种众所周知的技术来使fork操作更高效，该技术称为写时复制（copy on write），主要的原理是将
内存复制操作延迟到父进程或子进程向某内存页面写入数据之前，在只读访问的情况下父进程和子进程可以共用
同一内存页。例如，使用fork的一种可能的情况是，用户打开另一个浏览器窗口。如果选中了对应的选项，
浏览器将执行fork，复制其代码，接下来子进程中将启动适当的操作建立新窗口。

* exec将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，其内容将替换为新的数据。然后开始执行新程序。

### 线程

进程并不是内核支持的唯一一种程序执行形式。除了重量级进程（有时也称为UNIX进程）之外，还有一种形式是线程（有时也称为轻量级进程）。
线程也已经出现相当长的一段时间，本质上一个进程可能由若干线程组成，这些线程共享同样的数据和资源，但可能执行程序中不同的代码路径。
线程概念已经完全集成到许多现代编程语言中，例如Java。简而言之，进程可以看作一个正在执行的程序，而线程则是与主程序并行运行的程序
函数或例程。该特性是有用的，例如在浏览器需要并行加载若干图像时。通常浏览器只好执行几次fork和exec调用，以此创建若干并行的进程实例。
这些进程负责加载图像，并使用某种通信机制将接收的数据提供给主程序。在使用线程时，这种情况更容易处理一些。浏览器定义了一个例程来加载图像，
可以将例程作为线程启动，使用参数不同的多个线程即可。由于线程和主程序共享同样的地址空间，主程序自动就可以访问接收到的数据。
因此除了为防止线程访问同一内存区而采取的互斥机制外，就不需要什么通信了。

Linux用clone方法创建线程。其工作方式类似于fork，但启用了精确的检查，以确认哪些资源与父进程共享、哪些资源为线程独立创建。
这种细粒度的资源分配扩展了一般的线程概念，在一定程度上允许线程与进程之间的连续转换。

### 命名空间

在内核2.6的开发期间，对命名空间的支持被集成到了许多子系统中。这使得不同的进程可以看到不同的系统视图。
传统的Linux（与一般的UNIX操作系统）使用许多全局量，例如进程ID。系统中的每个进程都有一个唯一标识符（ID），
用户（或其他进程）可使用ID来访问进程，例如向进程发一个信号。启用命名空间之后，以前的全局资源现在具有不同分组。
每个命名空间可以包含一个特定的PID集合，或可以提供文件系统的不同视图，在某个命名空间中挂载的卷不会传播到其他命名空间中。
命名空间很有用处。举例来说，该特性对虚拟主机供应商是有益的。他们不必再为每个用户准备一台物理计算机，而是通过称为
容器的命名空间来建立系统的多个视图。从容器内部看来这是一个完整的Linux系统，而且与其他容器没有交互。容器是彼此分离的。
每个容器实例看起来就像是运行Linux的一台计算机，但事实上一台物理机器可以同时运转许多这样的容器实例。这有助于更有效地使用资源。
与完全的虚拟化解决方案（如KVM）相比，计算机上只需要运行一个内核来管理所有的容器。

### 地址空间

由于内存区域是通过指针寻址，因此CPU的字长决定了所能管理的地址空间的最大长度。对32位系统（如IA-32、PPC、m68k），是2^32B=4GiB，
对更现代的64位处理器（如Alpha、Sparc64、IA-64、AMD64），可以管理2^64B。地址空间的最大长度与实际可用的物理内存数量无关，
因此被称为虚拟地址空间。使用该术语的另一个理由是，从系统中每个进程的角度来看，地址空间中只有自身一个进程，
而无法感知到其他进程的存在。应用程序无需关注其他程序的存在，好像计算机中只有一个进程一样。Linux将虚拟地址空间划分为两个部分，
分别称为内核空间和用户空间，如图所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/res/virtual_space.png

系统中每个用户进程都有自身的虚拟地址范围，从0到TASK_SIZE。用户空间之上的区域
（从TASK_SIZE到232或264）保留给内核专用，用户进程不能访问。TASK_SIZE是一个特定于
计算机体系结构的常数，把地址空间按给定比例划分为两部分。例如在IA-32系统中，
地址空间在3 GiB处划分，因此每个进程的虚拟地址空间是3 GiB。由于虚拟地址空间的总长度是4 GiB，
所以内核空间有1 GiB可用。尽管实际的数字依不同的计算机体系结构而不同，但一般概念都是相同的。
因此我在进一步讨论中将使用例子中的这些值。这种划分与可用的内存数量无关。由于地址空间虚拟化的结果，
每个用户进程都认为自身有3 GiB内存。各个系统进程的用户空间是完全彼此分离的。而虚拟地址空间顶部的
内核空间总是同样的，无论当前执行的是哪个进程。
注意，64位计算机的情况可能更复杂，因为它们在实际管理自身巨大的理论虚拟地址空间时，倾向于使用小于
64的位数。实际使用的位数一般小于64位，如42位或47位。因此，地址空间中实际可寻址的部分小于理论长度。
但无论如何，该值仍然大于计算机上实际可能的内存数量，因此是完全够用的。这种做法的一个优点是，与
寻址完整的虚拟地址空间相比，管理有效地址空间所需的位数较少，因此CPU可以节省一些工作量。这样，
虚拟地址空间会包含一些不可寻址的洞.

### 特权级别

内核把虚拟地址空间划分为两个部分，因此能够保护各个系统进程，使之彼此隔离。所有的现代CPU都提供了几种特权级别，
进程可以驻留在某一特权级别。每个特权级别都有各种限制，例如对执行某些汇编语言指令或访问虚拟地址空间某一特定部分的限制。
IA-32体系结构使用4种特权级别构成的系统，各级别可以看作是环。内环能够访问更多的功能，外环则较少，如图所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/res/privilege.png

尽管英特尔处理器区分4种特权级别，但Linux只使用两种不同的状态：核心态和用户状态。
两种状态的关键差别在于对高于TASK_SIZE的内存区域的访问。简而言之，在用户状态禁止访问内核空间。
用户进程不能操作或读取内核空间中的数据，也无法执行内核空间中的代码。这是内核的专用领域。
这种机制可防止进程无意间修改彼此的数据而造成相互干扰。从用户状态到核心态的切换通过系统调用
的特定转换手段完成，且系统调用的执行因具体系统而不同。如果普通进程想要执行任何影响整个系统的操作
（例如操作输入/输出装置），则只能借助于系统调用向内核发出请求。内核首先检查进程是否允许执行想要的操作，
然后代表进程执行所需的操作，接下来返回到用户状态。除了代表用户程序执行代码之外，内核还可以由异步硬件中断激活，
然后在中断上下文中运行。与在进程上下文中运行的主要区别是，在中断上下文中运行不能访问虚拟地址空间中的用户空间部分。
因为中断可能随机发生，中断发生时可能是任一用户进程处于活动状态，由于该进程基本上与中断的原因无关，
因此内核无权访问当前用户空间的内容。在中断上下文中运行时，内核必须比正常情况更加谨慎，
例如，不能进入睡眠状态。在编写中断处理程序时需要特别注意这些.

除了普通进程，系统中还有内核线程在运行。内核线程也不与任何特定的用户空间进程相关联，因此也无权处理用户空间。
不过在其他许多方面，内核线程更像是普通的用户层应用程序。与在中断上下文运转的内核相比，内核线程可以进入睡眠状态，
也可以像系统中的普通进程一样被调度器跟踪。内核线程可用于各种用途：从内存和块设备之间的数据同步，到帮助调度器在CPU上分配进程。
在多处理器系统上，许多线程启动时指定了CPU，并限制只能在某个特定的CPU上运行。从内核线程名称之后的斜线和CPU编号可以看到这一点。

进程生命周期
----------------------------------------

进程并不总是可以立即运行。有时候它必须等待来自外部信号源、不受其控制的事件，例如在文本编辑器中等待键盘输入。
在事件发生之前，进程无法运行。当调度器在进程之间切换时，必须知道系统中每个进程的状态。将CPU时间分配到无事可做
的进程，显然是没有意义的。进程在各个状态之间的转换也同样重要。例如，如果一个进程在等待来自外设的数据，那么
调度器的职责是一旦数据已经到达，则需要将进程的状态由等待改为可运行。进程可能有以下几种状态。

* 运行: 该进程此刻正在执行。
* 等待：进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。
* 睡眠：进程正在睡眠无法运行，因为它在等待一个外部事件。调度器无法在下一次任务切换时选择该进程。

系统将所有进程保存在一个进程表中，无论其状态是运行、睡眠或等待。但睡眠进程会特别标记出来，调度器会知道它们无法立即运行。
睡眠进程会分类到若干队列中，因此它们可在适当的时间唤醒，例如在进程等待的外部事件已经发生时。下图描述了进程的几种状态及其转换。

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/res/task_state.png

对于一个排队中的可运行进程，我们来考察其各种可能的状态转换。该进程已经就绪，但没有运行，因为CPU分配给了其他进程（因此该进程的状态是“等待”）。
在调度器授予CPU时间之前，进程会一直保持该状态。在分配CPU时间之后，其状态改变为“运行”（路径④）。在调度器决定从该进程收回CPU资源时，
进程状态从“运行”改变为“等待”（路径②），循环重新开始。实际上根据是否可以被信号中断，有两种“睡眠”状态。现在这种差别还不重要，
但在更仔细地考察具体实现时，其差别就相对重要了。如果进程必须等待事件，则其状态从“运行”改变为“睡眠”（路径①）。
但进程状态无法从“睡眠”直接改变为“运行”。在所等待的事件发生后，进程先变回到“等待”状态（路径③），然后重新回到正常循环。
在程序执行终止（例如，用户关闭应用程序）后，过程状态由“运行”变为“终止”（路径⑤）。

上文没有列出的一个特殊的进程状态是所谓的“僵尸”状态。顾名思义，这样的进程已经死亡，但仍然以某种方式活着。
实际上，说这些进程死了，是因为其资源（内存、与外设的连接，等等）已经释放，因此它们无法也决不会再次运行。
说它们仍然活着，是因为进程表中仍然有对应的表项。

僵尸是如何产生的?
其原因在于UNIX操作系统下进程创建和销毁的方式。在两种事件发生时，程序将终止运行。
第一，程序必须由另一个进程或一个用户杀死（通常是通过发送SIGTERM或SIGKILL信号来完成，这等价于正常地终止进程）；
进程的父进程在子进程终止时必须调用或已经调用wait4（读做wait for）系统调用。这相当于向内核证实父进程已经确认子进程的终结。
该系统调用使得内核可以释放为子进程保留的资源。只有在第一个条件发生（程序终止）而第二个条件不成立的情况下（wait4），
才会出现“僵尸”状态。在进程终止之后，其数据尚未从进程表删除之前，进程总是暂时处于“僵尸”状态。
有时候（例如，如果父进程编程极其糟糕，没有发出wait调用），僵尸进程可能稳定地寄身于进程表中，直至下一次系统重启。
从进程工具（如ps或top）的输出，可以看到僵尸进程。因为残余的数据在内核中占据的空间极少，所有这几乎不是一个问题。

进程表示
----------------------------------------

Linux内核涉及进程和程序的所有算法都围绕一个名为task_struct的数据结构建立，该结构定义如下所示:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/include/linux/sched.h/task_struct.md

进程类型
----------------------------------------

典型的UNIX进程包括：由二进制代码组成的应用程序、单线程（计算机沿单一路径通过代码，不会有其他路径
同时运行）、分配给应用程序的一组资源（如内存、文件等）。新进程是使用fork和exec系统调用产生的。

* fork生成当前进程的一个相同副本，该副本称之为子进程。原进程的所有资源都以适当的方式复制到子进程，
  因此该系统调用之后，原来的进程就有了两个独立的实例。这两个实例的联系包括：同一组打开文件、同样
  的工作目录、内存中同样的数据（两个进程各有一份副本），等等。此外二者别无关联。

* exec从一个可执行的二进制文件加载另一个应用程序，来代替当前运行的进程。换句话说，加载了一个新程序。
  因为exec并不创建新进程，所以必须首先使用fork复制一个旧的程序，然后调用exec在系统上创建另一个应用
  程序。

除此之外Linux还提供了clone系统调用。clone的工作原理基本上与fork相同，但新进程不是独立于父进程的，
而可以与其共享某些资源。可以指定需要共享和复制的资源种类，例如，父进程的内存数据、打开文件或
安装的信号处理程序。

init_task
----------------------------------------

init_task在Linux系统中，只有这个进程是静态分配的:

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/arch/arm/kernel/init_task.c/README.md

进程创建
----------------------------------------

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/fork.c/README.md

进程调度
----------------------------------------

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/sched/core.c/__schedule.md
