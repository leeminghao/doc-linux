swi软中断
========================================

在ARM平台上，使用了swi中断来实现系统调用的跳转. swi指令用于产生软件中断, 从而实现从用户模式变换到
管理模式, CPSR(Current Program Status Register), 程序状态寄存器,包含了条件标志位,中断禁止位,当前
处理器模式标志以及其他的一些控制和状态位)保存到管理模式的SPSR(Saved Program Status Register,程序
状态保存寄存器,用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态),执行转移到swi向量,
在其他模式下也可使用swi指令，处理器同样地切换到管理模式。

程序在用户态运行，当发生系统调用、异常、中断等事件，就会切换到另一个模式，
此时CPU硬件会做如下几种事情：
* 1.关中断
* 2.将cpsr的值保存到目标模式的spsr中
* 3.通过修改cpsr的模式位，切换到目标模式。
* 4.将当前pc值加上一定偏移（0或4），写入到目标模式的lr中。
* 5.将pc值指向异常向量表
之后就会执行异常处理流程。
参看fork系统调用处理流程:

### fork

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/kernel/fork_c/fork.md


指令格式
----------------------------------------

```
swi {cond}  immed_24
```

其中:

immed_24 24位立即数，值为从0-16777215之间的整数。使用swi指令时,通常使用以下两种方法进行参数传递,
swi异常处理程序可以提供相关的服务,这两种方法均是用户软件协定.swi异常中断处理程序要通过读取引起
软件中断的swi指令,以取得24位立即数.

* 1.指令中24位的立即数指定了用户请求的服务类型,参数通过通用寄存器传递.如:

```
    MOV R0,#34
    SWI 12
```

* 2.指令中的24位立即数被忽略,用户请求的服务类型有寄存器R0的值决定,参数通过其他的通用寄存器传递.如:

```
    MOV R0, #12
    MOV R1, #34
    SWI 0
```

在SWI中断处理程序中,取出SWI立即数的步骤为:

* 首先, 确定一起软中断的SWI指令时ARM指令还是Thumb指令,这可通过对SPSR访问得到;
* 然后, 取得该SWI指令的地址, 这可通过访问LR寄存器得到, 接着读出指令,分解出立即数(低24位).

系统会根据ABI的不同而将相应的系统调用表的基地址加载进tbl寄存器,接下来查找的过程:

Linux kernel swi中断处理函数
----------------------------------------

用swi指令即可触发软中断，并切换到内核态(管理模式)。此时CPU就做的事情就是:

* 1.关中断
* 2.将cpsr值写入到spsr_svc中
* 3.将cpsr[5:0]设置成0b10011（svc模式）
* 4.将pc值+4的地址，也就是swi指令的下一行地址写入lr_svc中
* 5.__vectors_start+8写入pc（向量表第三项，系统调用的处理函数）

https://github.com/leeminghao/doc-linux/blob/master/4.x.y/arch/arm/kernel/entry-armv.S/__vector_start.md
