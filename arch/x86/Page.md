分页机制
================================================================================

总述
--------------------------------------------------------------------------------

分页机制是80x86内存管理机制的第二部分。它在分段机制的基础上完成线性地址到物理地址转换的过程。
分段机制把逻辑地址转换成线性地址，而分页则把线性地址转换成物理地址。
分页可以用于任何一种分段模型。处理器分页机制会把线性地址空间（段已映射到其中）划分成页面，
然后这些线性地址空间页面被映射到物理地址空间的页面上。

分页机制有几种页面级保护措施，可和分段机制保护机制合用或替代分段机制的保护措施。
例如，在基于页面的基础上可以加强读/写保护。另外，在页面单元上，分页机制还提供了用户-超级用户两级保护。

我们通过设置控制寄存器CR0的PG位可以启用分页机制。

* 如果PG=1，则启用分页操作，处理器会使用本节描述的机制将线性地址转换成物理地址。
* 如果PG=0，则禁用分页机制，此时分段机制产生的线性地址被直接用作物理地址。

分段机制在各种可变长度的内存区域上操作。与分段机制不同，分页机制对固定大小的内存块（称为页面）进行操作。
分页机制把线性和物理地址空间都划分成页面。线性地址空间中的任何页面可以被映射到物理地址空间的任何页面上。

80x86使用4K字节固定大小的页面。每个页面均是4KB，并且对齐于4K地址边界处。
这表示分页机制把4GB的线性地址空间划分成1M = 1048576个页面。
分页机制通过把线性地址空间中的页面重新定位到物理地址空间中进行操作。
由于4KB大小的页面作为一个单元进行映射，并且对齐于4K边界，因此线性地址的低12位可作为页内偏移量直接作为物理地址的低12位。
**分页机制执行的重定位功能可看做把线性地址的高20位转换到对应物理地址的高20位。**

另外，线性到物理地址的转换功能被扩展成允许一个线性地址被标注为无效的，而非让其产生一个物理地址。
在两种情况下一个页面可以被标注为无效的：
* 操作系统不支持的线性地址；
* 对应在虚拟内存系统中的页面在磁盘上而非在物理内存中。
在第一种情况下，产生无效地址的程序必须被终止。
在第二种情况下，该无效地址实际上是请求操作系统虚拟内存管理器把对应页面从磁盘上加载到物理内存中，以供程序访问。
因为无效页面通常与虚拟存储系统相关，因此它们被称为不存在的页面，并且由页表中称为存在（present）的属性来确定。

在保护模式中，80x86允许线性地址空间直接映射到大容量的物理内存（如4GB的RAM）上，
或者（使用分页）间接地映射到较小容量的物理内存和磁盘存储空间中。
这后一种映射线性地址空间的方法被称为虚拟存储或者需求页（Demand-paged）虚拟存储。

当使用分页时，处理器会把线性地址空间划分成固定大小的页面（长度4KB），这些页面可以映射到物理内存中或磁盘存储空间中。
当一个程序（或任务）引用内存中的逻辑地址时，处理器会把该逻辑地址转换成一个线性地址，然后使用分页机制把该线性地址转换成对应的物理地址。

如果包含线性地址的页面当前不在物理内存中，处理器就会产生一个页错误异常。
页错误异常的处理程序通常就会让操作系统从磁盘中把相应页面加载到物理内存中
（操作过程中可能还会把物理内存中不同的页面写到磁盘上）。当页面加载到物理内存中之后，
从异常处理过程的返回操作会使得导致异常的指令被重新执行。处理器用于把线性地址转换成
物理地址时所需的信息及处理器产生页错误异常（若必要的话）所需的信息都存储于页目录和页表中。

分页与分段最大的不同之处在于分页使用了固定长度的页面。段的长度通常与存放在其中的代码或数据结构具有相同的长度。
与段不同，页面有固定的长度。如果仅使用分段地址转换，那么存储在物理内存中的一个数据结构将包含其所有的部分。
但如果使用了分页，那么一个数据结构就可以一部分存储于物理内存中，而另一部分保存在磁盘中。

为了减少地址转换所要求的总线周期数量，最近访问的页目录和页表会被存放在处理器的缓冲器件中。
该缓冲器件被称为转换查找缓冲区（Translation Lookaside Buffer，TLB）。
TLB可以满足大多数读页目录和页表的请求而无需使用总线周期。
只有当TLB中不包含要求的页表项时才会使用额外的总线周期从内存中读取页表项，
通常在一个页表项很长时间没有访问过时才会出现这种情况。

页表结构
--------------------------------------------------------------------------------

分页转换功能由驻留在内存中的表来描述，该表称为页表（page table），存放在物理地址空间中。
页表可看做简单的220个物理地址数组。线性到物理地址的映射功能可以简单地看做进行数组查找。
线性地址的高20位构成这个数组的索引值，用于选择对应页面的物理（基）地址。
线性地址的低12位给出了页面中的偏移量，加上页面的基地址最终形成对应的物理地址。
由于页面基地址对齐在4K边界上，因此页面基地址的低12位肯定是0。这意味着高20位的页面基地址和12位偏移量连接组合在一起就能得到对应的物理地址。

页表中每个页表项的大小为32位。由于只需要其中的20位来存放页面的物理基地址，因此剩下的12位可用于存放诸如页面是否存在等的属性信息:
* 如果线性地址索引的页表项被标注为存在的，则表示该项有效，我们可以从中取得页面的物理地址。
* 如果页表项中信息表明页不存在，那么当访问对应物理页面时就会产生一个异常。

### 两级页表结构

页表含有1M个表项，而每项占用4B。如果作为一个表来存放的话，它们最多将占用4MB的内存。
因此为了减少内存占用量，80x86使用了两级表。由此，高20位线性地址到物理地址的转换也被分成两步来进行，每步使用（转换）其中的10bit。

* 第一级表称为页目录（page directory）:
  它被存放在1页4K页面中，具有210（1K）个4B长度的表项。这些表项指向对应的二级表。
  线性地址的最高10位（位31～22）用作一级表（页目录）中的索引值来选择210个二级表之一。

* 第二级表称为页表（page table）:
  它的长度也是1个页面，最多含有1K个4B的表项。每个4B表项含有相关页面的20位物理基地址。
  二级页表使用线性地址中间10位（位21～12）作为表项索引值，以获取含有页面20位物理基地址的表项。
  该20位页面物理基地址和线性地址中的低12位（页内偏移）组合在一起就得到了分页转换过程的输出值，即对应的最终物理地址。

如下图所示， 给出了二级表的查找过程：

其中CR3寄存器指定页目录表的基地址， 线性地址的高10位用于索引这个页目录表，以获得指向相关第二级页表的指针。
线性地址中间10位用于索引二级页表，以获得物理地址的高20位。
线性地址的低12位直接作为物理地址低12位，从而组成一个完整的32位物理地址。

https://github.com/leeminghao/doc-linux/blob/master/arch/x86/linetophysic.png

### 不存在的页表

使用二级表结构，并没有解决需要使用4MB内存来存放页表的问题。实际上，我们把问题搞得有些复杂了。
因为我们需要另增一个页面来存放目录表。然而，二级表结构允许页表被分散在内存各个页面中，
而不需要保存在连续的4MB内存块中。另外，并不需要为不存在的或线性地址空间未使用部分分配二级页表。
虽然目录表页面必须总是存在于物理内存中，但是二级页表可以在需要时再分配。这使得页表结构的大小对应于实际使用的线性地址空间大小。

页目录表中每个表项也有一个存在（present）属性，类似于页表中的表项。页目录表项中的存在属性指明对应的二级页表是否存在。
如果目录表项指明对应的二级页表存在，那么通过访问二级表，表查找过程第2步将同如上描述继续下去。
如果存在位表明对应的二级表不存在，那么处理器就会产生一个异常来通知操作系统。
页目录表项中的存在属性使得操作系统可以根据实际使用的线性地址范围来分配二级页表页面。

目录表项中的存在位还可以用于在虚拟内存中存放二级页表。这意味着在任何时候只有部分二级页表需要存放在物理内存中，
而其余的可保存在磁盘上。处于物理内存中页表对应的页目录项将被标注为存在，
以表明可用它们进行分页转换。处于磁盘上的页表对应的页目录项将被标注为不存在。
由于二级页表不存在而引发的异常会通知操作系统把缺少的页表从磁盘上加载进物理内存。
把页表存储在虚拟内存中减少了保存分页转换表所需要的物理内存量。

页表项格式
--------------------------------------------------------------------------------

页目录和页表的表项格式如下图所示:
其中位31～12含有物理地址的高20位，用于定位物理地址空间中一个页面（也称为页帧）的物理基地址。
表项的低12位含有页属性信息。前文已经讨论过存在属性，这里简要说明其余属性的功能和用途。

https://github.com/leeminghao/doc-linux/blob/master/arch/x86/page_table_item.png

* P: 位0是存在（Present）标志，用于指明表项对地址转换是否有效。P=1表示有效；P=0表示无效。
     在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常。
     如果P=0，那么除表示表项无效外，其余位可供程序自由使用，如图b所示。例如，操作系统可以使用这些位来保存已存储在磁盘上的页面的序号。
* R/W: 位1是读/写（Read/Write）标志。如果等于1，表示页面可以被读、写或执行。如果为0，表示页面只读或可执行。
     当处理器运行在超级用户特权级（级别0、1或2）时，则R/W位不起作用。页目录项中的R/W位对其所映射的所有页面起作用。
* U/S: 位2是用户/超级用户（User/Supervisor）标志。
     如果为1，那么运行在任何特权级上的程序都可以访问该页面。
     如果为0，那么页面只能被运行在超级用户特权级（0、1或2）上的程序访问。页目录项中的U/S位对其所映射的所有页面起作用。
* A: 位5是已访问（Accessed）标志。
     当处理器访问页表项映射的页面时，页表表项的这个标志就会被置为1。当处理器访问页目录表项映射的任何页面时，
     页目录表项的这个标志就会被置为1。处理器只负责设置该标志，操作系统可通过定期地复位该标志来统计页面的使用情况。
* D: 位6是页面已被修改（Dirty）标志。当处理器对一个页面执行写操作时，就会设置对应页表表项的D标志。处理器并不会修改页目录项中的D标志。
* AVL: 该字段保留专供程序使用。处理器不会修改这几位，以后的升级处理器也不会。

**虚拟存储**:
页目录和页表表项中的存在标志P为使用分页技术的虚拟存储提供了必要的支持。
若线性地址空间中的页面存在于物理内存中，则对应表项中的标志P=1，并且该表项中含有相应物理地址。
页面不在物理内存中的表项其标志P = 0。如果程序访问物理内存中不存在的页面，处理器就会产生一个缺页异常。
此时操作系统就可以利用这个异常处理过程把缺少的页面从磁盘上调入物理内存中，并把相应物理地址存放在表项中。
最后在返回程序重新执行引起异常的指令之前设置标志P=1。

已访问标志A和已修改标志D可以用于有效地实现虚拟存储技术。
通过周期性地检查和复位所有A标志，操作系统能够确定哪些页面最近没有访问过。
这些页面可以成为移出到磁盘上的候选者。假设当一页面从磁盘上读入内存时，其脏标志D=0，
那么当页面再次被移出到磁盘上时，若D标志还是为0，则该页面就无需被写入磁盘中。
若此时D=1，则说明页面内容已被修改过，于是就必须将该页面写到磁盘上。