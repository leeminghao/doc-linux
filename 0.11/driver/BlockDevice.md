Linux 0.11 块设备驱动程序
================================================================================

在 Linux 0.11 内核中主要支持硬盘和软盘驱动器两种块设备。

总体功能:
--------------------------------------------------------------------------------

对硬盘和软盘块设备上数据的读写操作是通过中断处理程序进行的。
每次读写的数据量以一个逻辑块(1024 字节)为单位,而块设备控制器则是以扇区(512字节)为单位。

在处理过程中,使用了读写请求项等待队列来顺序缓冲一次读写多个逻辑块的操作。当程序需要读取硬盘上的
一个逻辑块时,就会向缓冲区管理程序提出申请,而程序的进程则进入睡眠等待状态。缓冲区管理程序首先在
缓冲区中寻找以前是否已经读取过这块数据。如果缓冲区中已经有了,就直接将对应的缓冲区块头指针返回给
程序并唤醒该程序进程。若缓冲区中不存在所要求的数据块,则缓冲管理程序就会调用本章中的低级块读写
函数ll_rw_block(),向相应的块设备驱动程序发出一个读数据块的操作请求。该函数就会为此创建一个请求结构
项,并插入请求队列中。为了提供读写磁盘的效率,减小磁头移动的距离,在插入请求项时使用了电梯移动算法。

当对应的块设备的请求项队列空时,表明此刻该块设备不忙。于是内核就会立刻向该块设备的控制
器发出读数据命令。当块设备的控制器将数据读入到指定的缓冲块中后,就会发出中断请求信号,并调
用相应的读命令后处理函数,处理继续读扇区操作或者结束本次请求项的过程。对相应块设备进行关闭操作
和设置该缓冲块数据已经更新标志,最后唤醒等待该块数据的进程。

块设备操作方式:
--------------------------------------------------------------------------------
在系统(内核)与硬盘(块设备)进行IO操作时,需要考虑三个对象之间的交互作用.
它们是: 系统, 控制器和驱动器(例如硬盘或软盘驱动器). 如下图所示：

https://github.com/leeminghao/doc-linux/blob/master/0.11/driver/block_device_control.png

系统可以直接向控制器发送命令或等待控制器发出中断请求; 控制器在接收到命令后就会控制驱动器的操作,
读/写数据或者进行其它操作。因此我们可以把这里控制器发出的中断信号看作是这三者之间的同步操作信号,
所经历的操作步骤为:

1. 首先, 系统指明控制器在执行命令结束而引发的中断过程中应该调用的C函数,然后向块设备控制器发送
   读、写、复位或其它操作命令; 当控制器完成了指定的命令,会发出中断请求信号,引发系统执行块设备
   的中断处理过程,并在其中调用指定的C函数对读/写或其它命令进行命令结束后的处理工作。

2. 对于写盘操作,系统需要在发出了写命令后(使用hd_out())等待控制器给予允许向控制器写数据
   的响应,也即需要查询等待控制器状态寄存器的数据请求服务标志DRQ置位。一旦DRQ置位,系统就
   可以向控制器缓冲区发送一个扇区的数据,同样也使用hd_out()函数。当控制器把数据全部写入
   驱动器(后发生错误)以后,还会产生中断请求信号,从而在中断处理过程中执行前面预设置的C函数
   (write_intr())。这个函数会查询是否还有数据要写。如果有,系统就再把一个扇区的数据传到
   控制器缓冲区中,然后再次等待控制器把数据写入驱动器后引发的中断,一直这样重复执行。
   如果此时所有数据都已经写入驱动器,则该C函数就执行本次写盘结束后的处理工作:唤醒等待该
   请求项有关数据的相关进程、唤醒等待请求项的进程、释放当前请求项并从链表中删除该请求项
   以及释放锁定的相关缓冲区。最后再调用请求项操作函数去执行下一个读 / 写盘请求项(若还有的话)。

3. 对于读盘操作,系统在向控制器发送出包括需要读的扇区开始位置、扇区数量等信息的命令后,就
   等待控制器产生中断信号。当控制器按照读命令的要求,把指定的一扇区数据从驱动器传到了自己的
   缓冲区之后就会发出中断请求。从而会执行到前面为读盘操作预设置的C函数(read_intr())。
   该函数首先把控制器缓冲区中一个扇区的数据放到系统的缓冲区中,调整系统缓冲区中当前写入位置,
   然后递减需读的扇区数量。若还有数据要读(递减结果值不为0),则继续等待控制器发出下一个中断信号。
   若此时所有要求的扇区都已经读到系统缓冲区中,就执行与上面写盘操作一样的结束处理工作。

注意：对于虚拟盘设备,由于它的读写操作不牵涉到与外部设备之间的同步操作,因此没有上述的中断处理过程。
当前请求项对虚拟设备的读写操作完全在do_rd_request()中实现。

块设备请求项和请求队列:
--------------------------------------------------------------------------------

低级读写函数 ll_rw_block() 是通过请求项来与各种块设备建立联系并发出读写请求。对于各种块设备,
内核使用了一张块设备表 blk_dev[] 来进行管理。每种块设备都在块设备表中占有一项。块设备表中每个
块设备项的结构为:
```
struct blk_dev_struct {
    void (*request_fn)(void);    // 请求项操作的函数指针。
    struct request * current_request; // 当前请求项指针。
};
extern struct blk_dev_struct blk_dev[NR_BLK_DEV]; // 块设备表(数组)(NR_BLK_DEV = 7)。
```
其中,第一个字段是一个函数指针,用于操作相应块设备的请求项。例如,
* 对于硬盘驱动程序,它是do_hd_request();
* 而对于软盘设备,它就是 do_floppy_request() 。
第二个字段是当前请求项结构指针,用于指明本块设备目前正在处理的请求项,初始化时都被置成NULL。
块设备表将在内核初始化时,在 init/main.c 程序调用各设备的初始化函数时被设置。
为了便于扩展,Linus 把块设备表建成了一个以主设备号为索引的数组。在Linux 0.11中,主设备号有7种,
如下表所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/driver/device_num.png

其中,主设备号1, 2和3分别对应块设备:虚拟盘、软盘和硬盘。在块设备数组中其它各项都被默认地置成NULL.
当内核发出一个块设备读写或其它操作请求时, ll_rw_block() 函数即会根据其参数中指明的操作命令
和数据缓冲块头中的设备号,利用对应的请求项操作函数do_XX_request()建立一个块设备请求项,并利
用电梯算法插入到请求项队列中。请求项队列由请求项数组中的项构成,共有32项,每个请求项的数据
结构如下所示:
```
struct request {
    int dev;                      // 使用的设备号(若为-1,表示该项空闲)。
    int cmd;                      // 命令(READ 或 WRITE)。
    int errors;                   // 操作时产生的错误次数。
    unsigned long sector;         // 起始扇区。(1 块=2 扇区)
    unsigned long nr_sectors;     // 读/写扇区数。
    char *buffer;                 // 数据缓冲区。
    struct task_struct * waiting; // 等待任务
    struct buffer_head * bh;      // 缓冲区头指针
    struct request * next;        // 指向下一请求项。
};
extern struct request request[NR_REQUEST]; // 请求队列数组(NR_REQUEST = 32)。
```
每个块设备的当前请求指针与请求项数组中该设备的请求项链表共同构成了该设备的请求队列。
项与项之间利用字段 next 指针形成链表。因此块设备项和相关的请求队列形成数组加链表结构，
主要原因是为了满足两个目的:
* 一是利用请求项的数组结构在搜索空闲请求块时可以进行循环操作,因此程序可以编制得很简洁;
* 二是为满足电梯算法插入请求项操作,因此也需要采用链表结构
对于一个当前空闲的块设备,当 ll_rw_block() 函数为其建立第一个请求项时,会让该设备的当前请
求项指针 current_request 直接指向刚建立的请求项,并且立刻调用对应设备的请求项操作函数开始执行
块设备读写操作。当一个块设备已经有几个请求项组成的链表存在, ll_rw_block() 就会利用电梯算法,
根据磁头移动距离最小原则,把新建的请求项插入到链表适当的位置处。另外,为满足读操作的优先权,
在为建立新的请求项而搜索请求项数组时,把建立写操作时的空闲项搜索范围限制在整个请求项数组的前
2/3范围内,而剩下的 1/3 请求项专门给读操作建立请求项使用。

硬盘设备命名方式:
--------------------------------------------------------------------------------

硬盘的主设备号是3。其它设备的主设备号分别为:
```
1-内存; 2-磁盘; 3-硬盘; 4-ttyx; 5-tty; 6-并行口, 7-非命名管道
```
由于1个硬盘中可以存在 1--4 个分区,因此硬盘还依据分区的不同用次设备号进行指定分区。
因此硬盘的逻辑设备号由以下方式构成:
```
设备号 = 主设备号 *256 + 次设备号
```
也即: dev_no = (major<<8) + minor
Linux 0.11中两个硬盘的所有逻辑设备号如下表所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/driver/hd_num.png

其中 0x300 和 0x305 并不与哪个分区对应,而是代表整个硬盘。

软盘驱动器的设备号:
--------------------------------------------------------------------------------

在Linux中,软驱的主设备号是2,次设备号 = TYPE*4 + DRIVE.
其中, DRIVE 为 0-3, 分别对应软驱A,B,C或D;
TYPE 是软驱的类型, 2 表示1.2M软驱,7表示1.44M软驱, 也即floppy.c中定义的软盘类型(floppy_type[])
数组的索引值.
软盘类型如下表所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/driver/floppy_type.png