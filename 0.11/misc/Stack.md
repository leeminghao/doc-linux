Linux 0.11 中的栈的介绍
================================================================================

Linux 0.11系统中共使用如下所示4种堆栈:

* 系统引导初始化时临时使用的堆栈；
* 进入保护模式之后提供内核程序初始化使用的堆栈，位于内核代码地址空间固定位置处, 该堆栈也是后来任务0使用的用户态堆栈；
* 每个任务通过系统调用，执行内核程序时使用的堆栈，我们称之为任务的内核态堆栈, 每个任务都有自己独立的内核态堆栈；
* 任务在用户态执行的堆栈，位于任务（进程）逻辑地址空间近末端处。

使用多个栈或在不同情况下使用不同栈的主要原因有两个：
* 首先，是由于从实模式进入保护模式，使得CPU对内存寻址访问方式发生了变化，因此需重新调整设置栈区域。
* 另外，为了解决不同CPU特权级共享使用堆栈带来的保护问题，执行0级的内核代码和执行3级的用户代码需要
使用不同的栈。当一个任务进入内核态运行时，就会使用其TSS段中给出的特权级0的堆栈指针tss.ss0、tss.esp0
即内核栈。原用户栈指针会被保存在内核栈中。而当从内核态返回用户态时，就会恢复使用用户态的堆栈。

下面分别对它们进行说明：

系统初始化时使用的堆栈
--------------------------------------------------------------------------------

### 开机初始化时(bootsect.S，setup.s)

当bootsect代码被ROM BIOS引导加载到物理内存0x7c00处时，并没有设置堆栈段，当然程序也没有使用堆栈。
直到bootsect被移动到0x9000:0处时，才把堆栈段寄存器SS设置为0x9000，堆栈指针esp寄存器设置为0xff00，
即堆栈顶端在0x9000:0xff00处，代码如下所示:

path: boot/bootsect.s
```
go: mov    ax,cs
    mov    ds,ax
    mov    es,ax
    ! put stack at 0x9ff00.
    mov    ss,ax
    mov    sp,#0xFF00        ! arbitrary value >>512
```

上述代码的作用是通过ax, 用CS的值0x9000来把数据段寄存器(DS), 附加段寄存器(ES), 栈基址寄存器(SS)
设置成与代码段寄存器(CS)相同的位置，并将栈顶指针SP指向偏移地址为0xFF00处。

**注意**:
SS和SP联合使用,就构成了栈数据在内存中的位置值。对这两个寄存器的设置为后面程序的栈操作(如push、pop等)
打下了基础.现在可以观察一下bootsect中的程序，在执行设置SS和SP的代码之前,没有出现过栈操作指令，而在
此之后就陆续使用。**这里对SS和SP进行的设置是分水岭**: 它标志着从现在开始，程序可以执行一些更为复杂
的数据运算类指令了.

栈操作是有方向的注意是由高地址到低地址的方向.
DS/ES/FS/GS/SS: 这些段寄存器存在于CPU中,其中SS(Stack Segment)指向栈段,此区域将按栈机制进行管理.
SP(Stack Pointer): 栈顶指针寄存器，指向栈段的当前栈顶.

setup.s程序中也沿用了bootsect中设置的堆栈段。这就是系统初始化时临时使用的堆栈。

### 进入保护模式时(head.s)

现在head程序正式开始执行,一切都是为适应保护模式做准备. 其本质就是让CS的用法从实模式转变到保护模式.
在实模式下时: **CS本身就是代码段基址**. 在保护模式下时: **CS本身并不是代码段基址, 而是代码段选择符**.
经前面分析知, jmpi 0, 8这句代码使CS和GDT表的第2项关联, 并且使代码段的基址指向了0x000000.
从现在开始, 要将DS, ES, FS和GS等其他寄存器从实模式转变到保护模式. 执行代码如下:

path: boot/head.s
```
pg_dir:
.globl startup_32
startup_32:
    movl $0x10,%eax
    mov %ax,%ds
    mov %ax,%es
    mov %ax,%fs
    mov %ax,%gs
    lss stack_start, %esp
```

SS现在也要转变为栈段选择符, 栈顶指针也成为32位的esp, 如下所示:

path: boot/head.s
```
    lss stack_start, %esp
```

在kernel/sched.c中, stack_start = { & user_stack [PAGE_SIZE>>2] , 0x10 }这行代码将栈顶指针
指向user_stack数据结构的最末位置, 这个数据结构是在kernel/sched.c中定义的, 如下所示:

path: kernel/sched.c
```
long user_stack [ PAGE_SIZE>>2 ] ;

struct {
    long * a;
    short b;
} stack_start = { & user_stack [PAGE_SIZE>>2] , 0x10 };
```

**注意**:
取段寄存器指令(Load Segment Instruction):
该组指令的功能是把内存单元的一个"低字"传送给指令中指定的16位寄存器, 把随后的一个"高字"传给相应的段寄存器(DS,ES,FS,GS和SS).
其指令格式如下:

```
LDS/LES/LFS/LGS/LSS　Reg, Mem
```

指令LDS(Load Data Segment Register)和LES(Load Extra Segment Register)在8086CPU中就存在,
而LFS和LGS(Load Extra Segment Register),LSS(Load Stack Segment Register)是80386及其以后CPU中才有的指令.

A. 如果Reg是16位寄存器,那么Mem必须是32位指针;

B. 如果Reg是32位寄存器, 那么Men必须是48位指针, 其低32位给指令中指定的寄存器, 高16位给指令中的段寄存器.

0x10将SS的值设置为与前面4个段选择符的值相同.
这样, SS与前面讲解过的4个段选择符相同, 段基址都指向0x000000,段限长都是8MB,特权级都是内核特权级,
栈顶指针esp指向user_stack数据结构的最末位置后面的压栈动作就要在这里进行.

此时该堆栈是内核程序自己使用的堆栈。其中给出的地址是大约值，它们与编译时的实际设置参数有关。

**在init/main.c程序中，在执行move_to_user_mode()代码把控制权移交给任务0之前，系统一直使用该堆栈。
而在执行过move_to_user_mode()之后，main.c的代码被"切换"到任务0中执行。通过执行fork()系统调用，
main.c中的init()将在任务1中执行，并使用任务1的堆栈。而main()本身则在被"切换"成为任务0后，仍然继续
使用上述内核程序自己的堆栈作为任务0的用户态堆栈.**

任务堆栈
--------------------------------------------------------------------------------

每个任务都有两个堆栈，分别用于用户态和内核态程序的执行，并且分别称为用户态堆栈和内核态堆栈。
除了处于不同CPU特权级中，这两个堆栈之间的主要区别在于任务的内核态堆栈很小，所保存的数据量最多不能
超过"4096 – 任务数据结构块个字节"，大约为3KB。而任务的用户态堆栈却可以在用户的64MB空间内延伸。

### 在用户态运行时堆栈 -- 用户栈

每个任务（除了任务0和任务1）有自己的64MB地址空间。当一个任务（进程）刚被创建时，它的用户态堆栈指针
被设置在其地址空间的靠近末端（64MB顶端）部分。实际上末端部分还要包括执行程序的参数和环境变量，然后
才是用户堆栈空间, 应用程序在用户态下运行时就一直使用这个堆栈。堆栈实际使用的物理内存则由CPU分页机制
确定。由于Linux实现了写时复制功能（Copy on Write），因此在进程被创建后，若该进程及其父进程都没有使用
堆栈，则两者共享同一堆栈对应的物理内存页面。只有当其中一个进程执行堆栈写操作（如push操作）时内核内存
管理程序才会为写操作进程分配新的内存页面。**而进程0和进程1的用户堆栈比较特殊**

### 在内核态运行时 -- 内核栈

每个任务都有自己的内核态堆栈，用于任务在内核代码中执行期间。其所在线性地址中的位置由该任务TSS段中
ss0和esp0两个字段指定。ss0是任务内核态堆栈的段选择符，esp0是堆栈栈底指针。因此每当任务从用户代码
转移进入内核代码中执行时，任务的内核态栈总是空的。任务内核态堆栈被设置在位于其任务数据结构所在页面
的末端，即与任务的任务数据结构（task_struct）放在同一页面内。这是在建立新任务时，fork()程序在任务
tss段的内核级堆栈字段（tss.esp0和tss.ss0）中设置的，代码如下所示:

path: kernel/fork.c
```
    // esp0是内核栈指针
    p->tss.esp0 = PAGE_SIZE + (long) p;
    // 0x10就是10000，0特权级，GDT，数据段
    p->tss.ss0 = 0x10;
```

任务内核栈如下图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/process/kernel_stack.jpg

为什么从主内存区申请得来的用于保存任务数据结构的一页内存也能被设置成内核数据段中的数据呢?
即: tss.ss0为什么能被设置成0x10呢?

这是因为用户内核态栈仍然属于内核数据空间, 我们可以从内核代码段的长度范围来说明:
在head.s程序的末端，分别设置了内核代码段和数据段的描述符，段长度都被设置成了16MB。这个长度值是
Linux 0.11内核所能支持的最大物理内存长度. 因此，内核代码可以寻址到整个物理内存范围中的任何位置，
当然也包括主内存区。每当任务执行内核程序而需要使用其内核栈时，CPU就会利用TSS结构把它的内核态堆栈
设置成由tss.ss0和tss.esp0这两个值构成。对CPU来讲，这两个值是只读的, 因此每当一个任务进入内核态执行
时，其内核态堆栈总是空的。

任务0和任务1的堆栈
--------------------------------------------------------------------------------

任务0（空闲进程idle）和任务1（初始化进程init）的堆栈比较特殊，需要特别予以说明:

任务0和任务1的代码段和数据段相同，限长也都是640KB，但它们被映射到不同的线性地址范围中。
任务0的段基地址从线性地址0开始，而任务1的段基地址从64MB开始, 但是它们全都映射到物理地址
0～640KB范围中, **这个地址范围也就是内核代码和基本数据所存放的地方。**

在执行了move_to_user_mode()之后，任务0和任务1的内核态堆栈分别位于各自任务数据结构所在页面的末端，
而任务0的用户态堆栈就是前面进入保护模式后所使用的堆栈，即sched.c的user_stack[]数组的位置。
由于任务1在创建时复制了任务0的用户堆栈，因此刚开始时任务0和任务1共享使用同一个用户堆栈空间。
但是当任务1开始运行时，由于任务1映射到user_stack[]处的页表项被设置成只读，使得任务1在执行堆栈操作
时将会引起写页面异常，从而内核会使用写时复制机制为任务1另行分配主内存区页面作为堆栈空间使用。
只有到此时，任务1才开始使用自己独立的用户堆栈内存页面。因此任务0的堆栈需要在任务1实际开始使用之前
保持“干净”，即任务0此时不能使用堆栈，以确保复制的堆栈页面中不含有任务0的数据。

任务0的内核态堆栈是在其人工设置的初始化任务数据结构中指定的，而它的用户态堆栈是在执行
move_to_user_mode()时，在模拟iret返回之前的堆栈中设置的, 参看:

https://github.com/leeminghao/doc-linux/blob/master/0.11/init/StartMainInit.md

我们知道，当进行特权级会发生变化的控制权转移时，目的代码会使用新特权级的堆栈，而原特权级代码堆栈
指针将保留在新堆栈中。因此这里先把任务0用户堆栈指针压入当前处于特权级0的堆栈中，同时把代码指针也
压入堆栈，然后执行IRET指令即可实现把控制权从特权级0的代码转移到特权级3的任务0代码中。在这个人工
设置内容的堆栈中，原esp值被设置成仍然是user_stack中原来的位置值，而原ss段选择符被设置成0x17，
即设置成用户态局部表LDT中的数据段选择符, 然后把任务0代码段选择符0x0f压入堆栈作为栈中原CS段的选择符，
把下一条指令的指针作为原EIP压入堆栈。

这样，通过执行IRET指令即可"返回"到任务0的代码中继续执行了。

任务内核态堆栈与用户态堆栈之间的切换
--------------------------------------------------------------------------------

在Linux 0.11系统中，所有中断服务程序都属于内核代码, 如果一个中断产生时任务正在用户代码中执行，
那么该中断就会引起CPU特权级从3级到0级的变化，此时CPU就会进行用户态堆栈到内核态堆栈的切换操作。
CPU会从当前任务的任务状态段TSS中取得新堆栈的段选择符和偏移值, 因为中断服务程序在内核中，
属于0级特权级代码，所以48位的内核态堆栈指针会从TSS的ss0和esp0字段中获得, 在定位了新堆栈
（内核态堆栈）之后，CPU就会首先把原用户态堆栈指针ss和esp压入内核态堆栈，随后把标志寄存器eflags的
内容和返回位置cs、eip压入内核态堆栈。

内核的系统调用是一个软件中断，因此任务调用系统调用时就会进入内核并执行内核中的中断服务代码。
此时内核代码就会使用该任务的内核态堆栈进行操作。同样，当进入内核程序时，由于特权级别发生了改变
（从用户态转到内核态），用户态堆栈的堆栈段和堆栈指针以及eflags会被保存在任务的内核态堆栈中。
而在执行iret退出内核程序返回到用户程序时，将恢复用户态的堆栈和eflags。

切换过程如下图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/misc/kernel_stack_user.jpg

如果一个任务正在内核态中运行，那么若CPU响应中断就不再需要进行堆栈切换操作，因为此时该任务运行的
内核代码已经在使用内核态堆栈，并且不涉及优先级别的变化，所以CPU仅把eflags和中断返回指针cs、eip压入
当前内核态堆栈，然后执行中断服务过程。